{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{483:function(e,t,n){\"use strict\";n.r(t);var r=n(50),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[n(\"h1\",{attrs:{id:\"dataset和runtime的生命周期\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#dataset和runtime的生命周期\"}},[e._v(\"#\")]),e._v(\" Dataset和Runtime的生命周期\")]),e._v(\" \"),n(\"p\",[e._v(\"目前，Fluid支持的默认Runtime是AlluxioRuntime。\\nFluid提供了Runtime接口，并且假设Runtime和Dataset是一对一的关系，支持开发者扩展不同的Runtime。\\n本文档介绍了Dataset和Runtime的生命周期，以及开发自己的Runtime的方法。介绍过程中，将假设用户需要基于JindoFS开发JindoRuntime。\")]),e._v(\" \"),n(\"h2\",{attrs:{id:\"dataset\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#dataset\"}},[e._v(\"#\")]),e._v(\" Dataset\")]),e._v(\" \"),n(\"p\",[e._v(\"Dataset的生命周期流程如图所示：\")]),e._v(\" \"),n(\"h2\",{attrs:{id:\"runtime\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#runtime\"}},[e._v(\"#\")]),e._v(\" Runtime\")]),e._v(\" \"),n(\"p\",[e._v(\"Runtime的生命周期流程如图所示：\")]),e._v(\" \"),n(\"p\",[e._v(\"其中，Engine的整体生命周期如下：\")]),e._v(\" \"),n(\"h3\",{attrs:{id:\"engine-setup\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#engine-setup\"}},[e._v(\"#\")]),e._v(\" Engine.Setup\")]),e._v(\" \"),n(\"p\",[e._v(\"ShouldSetupMaster：判断是否需要创建Master。\"),n(\"br\"),e._v(\"\\nSetupMaster：创建Master。\"),n(\"br\"),e._v(\"\\nCheckMasterReady：检查Master是否Ready。\"),n(\"br\"),e._v(\"\\nShouldCheckUFS：判断是否需要PrepareUFS.\"),n(\"br\"),e._v(\"\\nPrepareUFS：为分布式缓存集群设定远端存储点。\"),n(\"br\"),e._v(\"\\nShouldSetupWorkers：判断是否需要创建Worker。\"),n(\"br\"),e._v(\"\\nSetupWorkers：创建Worker。\"),n(\"br\"),e._v(\"\\nCheckWorkersReady：检查Master是否Ready。\"),n(\"br\"),e._v(\"\\nCheckAndUpdateRuntimeStatus：检查并更新Runtime的状态。\"),n(\"br\"),e._v(\"\\nUpdateDatesetStatus：更新Dataset的状态。\")]),e._v(\" \"),n(\"h3\",{attrs:{id:\"engine-createvolume\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#engine-createvolume\"}},[e._v(\"#\")]),e._v(\" Engine.CreateVolume\")]),e._v(\" \"),n(\"p\",[e._v(\"CreatePV：根据存储位置创建PV。\"),n(\"br\"),e._v(\"\\nCreatePVC：创建PVC。\")]),e._v(\" \"),n(\"h3\",{attrs:{id:\"engine-sync\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#engine-sync\"}},[e._v(\"#\")]),e._v(\" Engine.Sync\")]),e._v(\" \"),n(\"p\",[e._v(\"SyncMetadata：进行metadata的同步工作。\"),n(\"br\"),e._v(\"\\nCheckAndUpdateRuntimeStatus：检查并更新Runtime的状态。\"),n(\"br\"),e._v(\"\\nUpdateCacheOfDataset：更新Dataset的cacheStates。\"),n(\"br\"),e._v(\"\\nCheckRuntimeHealthy：检查分布式缓存集群的健康状态，根据检查结果修改Dataset的状态。\"),n(\"br\"),e._v(\"\\nSyncReplicas：比较Runtime的期待副本数和分布式缓存集群中的当前副本数。\"),n(\"br\"),e._v(\"\\nCheckAndUpdateRuntimeStatus：检查并更新Runtime的状态。\")]),e._v(\" \"),n(\"h1\",{attrs:{id:\"reconciler\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#reconciler\"}},[e._v(\"#\")]),e._v(\" Reconciler\")]),e._v(\" \"),n(\"p\",[e._v(\"Fluid使用了kubebuilder生成脚手架代码，脚手架代码基于controller runtime框架实现对Controller的管理。\\n在controller runtime框架中，真正的事件处理通过Reconcile方法暴露给CRD开发者。每种CRD必须定义一个实现了reconcile.Reconcile接口的Reconcile结构体，开发者只需在此结构体的Reconcile方法中去处理业务逻辑就可以了。\")]),e._v(\" \"),n(\"p\",[e._v(\"在Fluid中，已经定义了Runtime的Reconciler：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language-golang extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"// RuntimeReconciler is the default implementation\\ntype RuntimeReconciler struct {\\n\\tclient.Client\\n\\tLog      logr.Logger\\n\\tRecorder record.EventRecorder\\n\\t// Real implement\\n\\timplement RuntimeReconcilerInterface\\n}\\n\")])])]),n(\"p\",[e._v(\"其中，RuntimeReconcilerInterface接口定义了以下方法：\")]),e._v(\" \"),n(\"ul\",[n(\"li\",[n(\"p\",[e._v(\"ReconcileInternal、ReconcileRuntimeDeletion、AddFinalizerAndRequeue、GetRuntimeObjectMeta、GetDataset：Runtime的Reconciler已经实现。\")])]),e._v(\" \"),n(\"li\",[n(\"p\",[e._v(\"ReconcileRuntime：需要调用GetRuntime方法获取Runtime开发者自己定义Runtime，塞入ctx；调用ReconcileInternal实现具体逻辑。\")])]),e._v(\" \"),n(\"li\",[n(\"p\",[e._v(\"GetOrCreateEngine、RemoveEngine：需要Runtime开发者自己实现。\")])])]),e._v(\" \"),n(\"p\",[e._v(\"若要开发JindoRuntime，需要定义JindoRuntime的Reconciler，它是RuntimeReconcilerInterface的具体实现：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language-golang extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"// RuntimeReconciler reconciles a JindoRuntime object\\ntype RuntimeReconciler struct {\\n\\tScheme  *runtime.Scheme\\n\\tengines map[string]base.Engine\\n\\tmutex   *sync.Mutex\\n\\t*controllers.RuntimeReconciler\\n}\\n\")])])]),n(\"blockquote\",[n(\"p\",[e._v(\"其中包含了Runtime的Reconciler的地址。因此，可以通过它调用Runtime的Reconciler已经实现的方法。\\nRuntime的开发者还需要实现GetRuntime方法，以获得自己定义的Runtime。\")])]),e._v(\" \"),n(\"p\",[e._v(\"在创建JindoRuntime的Reconciler的时候，需要先创建Runtime的Reconciler，再把它的地址添加进来：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"func NewRuntimeReconciler(client client.Client,\\n\\tlog logr.Logger,\\n\\tscheme *runtime.Scheme,\\n\\trecorder record.EventRecorder) *RuntimeReconciler {\\n\\tr := &RuntimeReconciler{\\n\\t\\tScheme:  scheme,\\n\\t\\tmutex:   &sync.Mutex{},\\n\\t\\tengines: map[string]base.Engine{},\\n\\t}\\n\\tr.RuntimeReconciler = controllers.NewRuntimeReconciler(r, client, log, recorder)\\n\\treturn r\\n}\\n\")])])]),n(\"h1\",{attrs:{id:\"engine\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#engine\"}},[e._v(\"#\")]),e._v(\" Engine\")]),e._v(\" \"),n(\"p\",[e._v(\"Engine是Fluid抽象出的分布式缓存的管理引擎，Engine需要实现该接口：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language-golang extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"type Engine interface {\\n   // ID returns the id\\n   ID() string\\n   // Shutdown and clean up the engine\\n   Shutdown() error\\n   // Setup the engine\\n   Setup(ctx cruntime.ReconcileRequestContext) (ready bool, err error)\\n   // Setup the Volume\\n   CreateVolume() (err error)\\n   // Destroy the Volume\\n   DeleteVolume() (err error)\\n   // Sync syncs the alluxio runtime\\n   Sync(ctx cruntime.ReconcileRequestContext) error\\n}\\n\")])])]),n(\"p\",[n(\"code\",[e._v(\"pkg/ddc/base/template_engine.go\")]),e._v(\"中，为用户提供了一份engine的实现模板：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language-golang extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"type TemplateEngine struct {\\n\\tImplement\\n\\tId string\\n\\tclient.Client\\n\\tLog     logr.Logger\\n\\tContext cruntime.ReconcileRequestContext\\n}\\n\")])])]),n(\"blockquote\",[n(\"p\",[e._v(\"TemplateEngine实际只实现了ID、Setup、Sync方法。CreateVolume、 DeleteVolume、Shutdown方法只是调用了Runtime开发者具体实现的方法。\")])]),e._v(\" \"),n(\"p\",[e._v(\"TemplateEngine中包含的Implement接口是Runtime开发者的engine需要实现的接口：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language-golang extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"// The real engine should implement\\ntype Implement interface {\\n\\tUnderFileSystemService\\n\\t// Is the master ready\\n\\tCheckMasterReady() (ready bool, err error)\\n\\t// are the workers ready\\n\\tCheckWorkersReady() (ready bool, err error)\\n\\t// ShouldSetupMaster checks if we need setup the master\\n\\tShouldSetupMaster() (should bool, err error)\\n\\t// ShouldSetupWorkers checks if we need setup the workers\\n\\tShouldSetupWorkers() (should bool, err error)\\n\\tShouldCheckUFS() (should bool, err error)\\n\\t// setup the cache master\\n\\tSetupMaster() (err error)\\n\\t// setup the cache worker\\n\\tSetupWorkers() (err error)\\n\\t// check if it's Bound to the dataset\\n\\t// IsBoundToDataset() (bound bool, err error)\\n\\t// Bind to the dataset\\n\\tUpdateDatasetStatus(phase datav1alpha1.DatasetPhase) (err error)\\n\\t// Prepare the mounts and metadata if it's not ready\\n\\tPrepareUFS() (err error)\\n\\t// Shutdown and clean up the engine\\n\\tShutdown() error\\n\\t// AssignNodesToCache picks up the nodes for replicas\\n\\tAssignNodesToCache(desiredNum int32) (currentNum int32, err error)\\n\\t// CheckRuntimeHealthy checks runtime healthy\\n\\tCheckRuntimeHealthy() (err error)\\n\\t// UpdateCacheOfDataset updates cache of the dataset\\n\\tUpdateCacheOfDataset() (err error)\\n\\t// CheckAndUpdateRuntimeStatus checks and updates the status\\n\\tCheckAndUpdateRuntimeStatus() (ready bool, err error)\\n\\tCreateVolume() error\\n\\t// SyncReplicas syncs the replicas\\n\\tSyncReplicas(ctx cruntime.ReconcileRequestContext) error\\n\\t// SyncMetadata syncs all metadata from UFS\\n\\tSyncMetadata() (err error)\\n\\t// Destroy the Volume\\n\\tDeleteVolume() (err error)\\n\\t// BindToDataset binds the engine to dataset\\n\\tBindToDataset() (err error)\\n}\\n\\ntype UnderFileSystemService interface {\\n\\tUsedStorageBytes() (int64, error)\\n\\tFreeStorageBytes() (int64, error)\\n\\tTotalStorageBytes() (int64, error)\\n\\tTotalFileNums() (int64, error)\\n}\\n\")])])]),n(\"p\",[e._v(\"综上，每一个Runtime的engine都需要实现以下方法:\")]),e._v(\" \"),n(\"ul\",[n(\"li\",[e._v(\"CheckMasterReady\")]),e._v(\" \"),n(\"li\",[e._v(\"CheckWorkersReady\")]),e._v(\" \"),n(\"li\",[e._v(\"ShouldSetupMaster\")]),e._v(\" \"),n(\"li\",[e._v(\"ShouldSetupWorkers\")]),e._v(\" \"),n(\"li\",[e._v(\"ShouldCheckUFS\")]),e._v(\" \"),n(\"li\",[e._v(\"SetupMaster\")]),e._v(\" \"),n(\"li\",[e._v(\"SetupWorkers\")]),e._v(\" \"),n(\"li\",[e._v(\"UpdateDatasetStatus\")]),e._v(\" \"),n(\"li\",[e._v(\"PrepareUFS\")]),e._v(\" \"),n(\"li\",[e._v(\"AssignNodesToCache\")]),e._v(\" \"),n(\"li\",[e._v(\"CheckRuntimeHealthy\")]),e._v(\" \"),n(\"li\",[e._v(\"UpdateCacheOfDataset\")]),e._v(\" \"),n(\"li\",[e._v(\"BindToDataset\")]),e._v(\" \"),n(\"li\",[e._v(\"CheckAndUpdateRuntimeStatus\")]),e._v(\" \"),n(\"li\",[e._v(\"CreateVolume\")]),e._v(\" \"),n(\"li\",[e._v(\"SyncReplicas\")]),e._v(\" \"),n(\"li\",[e._v(\"SyncMetadata\")]),e._v(\" \"),n(\"li\",[e._v(\"DeleteVolume\")]),e._v(\" \"),n(\"li\",[e._v(\"UsedStorageBytes\")]),e._v(\" \"),n(\"li\",[e._v(\"FreeStorageBytes\")]),e._v(\" \"),n(\"li\",[e._v(\"TotalStorageBytes\")]),e._v(\" \"),n(\"li\",[e._v(\"TotalFileNums\")])]),e._v(\" \"),n(\"p\",[e._v(\"初始化Engine的方式可以参考\"),n(\"code\",[e._v(\"pkg/ddc/alluxio/engine.go\")]),e._v(\"中的Build方法, 并且需要注册到\"),n(\"code\",[e._v(\"pkg/ddc/factory.go\")]),e._v(\"  。\")]),e._v(\" \"),n(\"h1\",{attrs:{id:\"开发示例\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#开发示例\"}},[e._v(\"#\")]),e._v(\" 开发示例\")]),e._v(\" \"),n(\"h2\",{attrs:{id:\"安装kubebuilder\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#安装kubebuilder\"}},[e._v(\"#\")]),e._v(\" 安装kubebuilder\")]),e._v(\" \"),n(\"p\",[e._v(\"到 kubebuilder 的 \"),n(\"a\",{attrs:{href:\"https://github.com/kubernetes-dags/kubebuilder/releases/tag/v2.1.0\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"GitHub release 页面\"),n(\"OutboundLink\")],1),e._v(\"上下载与您操作系统对应的 kubebuilder 安装包。\")]),e._v(\" \"),n(\"p\",[e._v(\"将下载好的安装包解压后将其移动到 /usr/local/kubebuilder 目录下，并将 /usr/local/kubebuilder/bin 添加到您的 $PATH 路径下。\")]),e._v(\" \"),n(\"h2\",{attrs:{id:\"利用kubebuilder生成runtime的控制器\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#利用kubebuilder生成runtime的控制器\"}},[e._v(\"#\")]),e._v(\" 利用kubebuilder生成Runtime的控制器\")]),e._v(\" \"),n(\"p\",[e._v(\"创建JindoRuntimeController的相关代码：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language-shell extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-shell\"}},[n(\"code\",[e._v(\"kubebuilder create api --group data --version v1alpha1 --kind JindoRuntime --namespaced \"),n(\"span\",{pre:!0,attrs:{class:\"token boolean\"}},[e._v(\"true\")]),e._v(\"\\nCreate Resource \"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"[\")]),e._v(\"y/n\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"]\")]),e._v(\"\\ny\\nCreate Controller \"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"[\")]),e._v(\"y/n\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"]\")]),e._v(\"\\ny\\nWriting scaffold \"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[e._v(\"for\")]),e._v(\" you to edit\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"..\")]),e._v(\".\\napi/v1alpha1/jindoruntime_types.go\\ncontrollers/jindoruntime_controller.go\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token number\"}},[e._v(\"2020\")]),e._v(\"/10/25 \"),n(\"span\",{pre:!0,attrs:{class:\"token number\"}},[e._v(\"16\")]),e._v(\":21:06 error updating main.go: \"),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[e._v(\"open\")]),e._v(\" main.go: no such \"),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[e._v(\"file\")]),e._v(\" or directory\\n\")])])]),n(\"blockquote\",[n(\"p\",[e._v(\"注意此处错误可以忽略\")])]),e._v(\" \"),n(\"p\",[e._v(\"将\"),n(\"code\",[e._v(\"controllers/jindoruntime_controller.go\")]),e._v(\"拷贝到\"),n(\"code\",[e._v(\"pkg/controllers/v1alpha1/jindo\")])]),e._v(\" \"),n(\"div\",{staticClass:\"language-shell extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-shell\"}},[n(\"code\",[n(\"span\",{pre:!0,attrs:{class:\"token builtin class-name\"}},[e._v(\"cd\")]),e._v(\" fluid\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[e._v(\"mv\")]),e._v(\" controllers/jindoruntime_controller.go pkg/controllers/v1alpha1/jindo\\n\")])])]),n(\"p\",[e._v(\"修改jindoruntime_controller.go如下：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language-golang extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v('package jindo\\n\\nimport (\\n\\t\"context\"\\n\\t\"sync\"\\n\\t\"github.com/pkg/errors\"\\n\\t\"github.com/go-logr/logr\"\\n\\t\"k8s.io/apimachinery/pkg/runtime\"\\n\\t\"k8s.io/client-go/tools/record\"\\n\\tctrl \"sigs.k8s.io/controller-runtime\"\\n\\t\"sigs.k8s.io/controller-runtime/pkg/client\"\\n\\tdatav1alpha1 \"github.com/fluid-cloudnative/fluid/api/v1alpha1\"\\n\\t\"github.com/fluid-cloudnative/fluid/pkg/common\"\\n\\t\"github.com/fluid-cloudnative/fluid/pkg/controllers\"\\n\\t\"github.com/fluid-cloudnative/fluid/pkg/ddc/base\"\\n\\tcruntime \"github.com/fluid-cloudnative/fluid/pkg/runtime\"\\n\\t\"github.com/fluid-cloudnative/fluid/pkg/utils\"\\n)\\n\\n// Use compiler to check if the struct implements all the interface\\nvar _ controllers.RuntimeReconcilerInterface = (*RuntimeReconciler)(nil)\\n\\n// RuntimeReconciler reconciles a JindoRuntime object\\ntype RuntimeReconciler struct {\\n\\tScheme  *runtime.Scheme\\n\\tengines map[string]base.Engine\\n\\tmutex   *sync.Mutex\\n\\t*controllers.RuntimeReconciler\\n}\\n\\n// NewRuntimeReconciler create controller for watching runtime custom resources created\\nfunc NewRuntimeReconciler(client client.Client,\\n\\tlog logr.Logger,\\n\\tscheme *runtime.Scheme,\\n\\trecorder record.EventRecorder) *RuntimeReconciler {\\n\\tr := &RuntimeReconciler{\\n\\t\\tScheme:  scheme,\\n\\t\\tmutex:   &sync.Mutex{},\\n\\t\\tengines: map[string]base.Engine{},\\n\\t}\\n\\tr.RuntimeReconciler = controllers.NewRuntimeReconciler(r, client, log, recorder)\\n\\treturn r\\n}\\n\\n//Reconcile reconciles jindo runtime\\n// +kubebuilder:rbac:groups=data.fluid.io,resources=jindoruntimes,verbs=get;list;watch;create;update;patch;delete\\n// +kubebuilder:rbac:groups=data.fluid.io,resources=jindoruntimes/status,verbs=get;update;patch\\n\\nfunc (r *RuntimeReconciler) Reconcile(req ctrl.Request) (ctrl.Result, error) {\\n\\tctx := cruntime.ReconcileRequestContext{\\n\\t\\tContext:        context.Background(),\\n\\t\\tLog:            r.Log.WithValues(\"jindoruntime\", req.NamespacedName),\\n\\t\\tNamespacedName: req.NamespacedName,\\n\\t\\tRecorder:       r.Recorder,\\n\\t\\tCategory:       common.AccelerateCategory,\\n\\t\\tRuntimeType:    runtimeType,\\n\\t\\tClient:         r.Client,\\n\\t\\tFinalizerName:  runtimeResourceFinalizerName,\\n\\t}\\n\\n\\tctx.Log.V(1).Info(\"process the request\", \"request\", req)\\n\\n\\t//\\t1.Load the Runtime\\n\\truntime, err := r.getRuntime(ctx)\\n\\tif err != nil {\\n\\t\\tif utils.IgnoreNotFound(err) == nil {\\n\\t\\t\\tctx.Log.V(1).Info(\"The runtime is not found\", \"runtime\", ctx.NamespacedName)\\n\\t\\t\\treturn ctrl.Result{}, nil\\n\\t\\t} else {\\n\\t\\t\\tctx.Log.Error(err, \"Failed to get the ddc runtime\")\\n\\t\\t\\treturn utils.RequeueIfError(errors.Wrap(err, \"Unable to get ddc runtime\"))\\n\\t\\t}\\n\\t}\\n\\tctx.Runtime = runtime\\n\\tctx.Log.V(1).Info(\"process the runtime\", \"runtime\", ctx.Runtime)\\n\\n\\t// reconcile the implement\\n\\treturn r.ReconcileInternal(ctx)\\n}\\n\\n//SetupWithManager setups the manager with RuntimeReconciler\\nfunc (r *RuntimeReconciler) SetupWithManager(mgr ctrl.Manager) error {\\n\\treturn ctrl.NewControllerManagedBy(mgr).\\n\\t\\tFor(&datav1alpha1.JindoRuntime{}).\\n\\t\\tComplete(r)\\n}\\n')])])]),n(\"h2\",{attrs:{id:\"jindoruntim的数据结构\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jindoruntim的数据结构\"}},[e._v(\"#\")]),e._v(\" JindoRuntim的数据结构\")]),e._v(\" \"),n(\"p\",[e._v(\"在jindorutime_type.go中，根据需要，修改JindoRuntimeSpec和JindoRuntimeStatus的数据结构。\")]),e._v(\" \"),n(\"p\",[e._v(\"可以通过添加注释，控制kubectl get命令可以查询到的信息：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v('// +kubebuilder:object:root=true\\n// +kubebuilder:subresource:status\\n// +kubebuilder:printcolumn:name=\"Ready Masters\",type=\"integer\",JSONPath=`.status.masterNumberReady`,priority=10\\n// +kubebuilder:printcolumn:name=\"Desired Masters\",type=\"integer\",JSONPath=`.status.desiredMasterNumberScheduled`,priority=10\\n// +kubebuilder:printcolumn:name=\"Master Phase\",type=\"string\",JSONPath=`.status.masterPhase`,priority=0\\n// +kubebuilder:printcolumn:name=\"Ready Workers\",type=\"integer\",JSONPath=`.status.workerNumberReady`,priority=10\\n// +kubebuilder:printcolumn:name=\"Desired Workers\",type=\"integer\",JSONPath=`.status.desiredWorkerNumberScheduled`,priority=10\\n// +kubebuilder:printcolumn:name=\"Worker Phase\",type=\"string\",JSONPath=`.status.workerPhase`,priority=0\\n// +kubebuilder:printcolumn:name=\"Ready Fuses\",type=\"integer\",JSONPath=`.status.fuseNumberReady`,priority=10\\n// +kubebuilder:printcolumn:name=\"Desired Fuses\",type=\"integer\",JSONPath=`.status.desiredFuseNumberScheduled`,priority=10\\n// +kubebuilder:printcolumn:name=\"Fuse Phase\",type=\"string\",JSONPath=`.status.fusePhase`,priority=0\\n// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=`.metadata.creationTimestamp`,priority=0\\n// +genclient\\n')])])]),n(\"h2\",{attrs:{id:\"开发jindo-engine\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#开发jindo-engine\"}},[e._v(\"#\")]),e._v(\" 开发Jindo Engine\")]),e._v(\" \"),n(\"p\",[e._v(\"创建jindo engine的文件夹：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"mkdir pkg/ddc/jindo\\n\")])])]),n(\"p\",[e._v(\"在其中创建engine.go文件：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language-golang extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v('package jindo\\n\\nimport (\\n\\t\"fmt\"\\n\\tdatav1alpha1 \"github.com/fluid-cloudnative/fluid/api/v1alpha1\"\\n\\t\"github.com/fluid-cloudnative/fluid/pkg/ddc/base\"\\n\\tcruntime \"github.com/fluid-cloudnative/fluid/pkg/runtime\"\\n\\t\"github.com/fluid-cloudnative/fluid/pkg/utils/kubeclient\"\\n\\t\"github.com/go-logr/logr\"\\n\\t\"sigs.k8s.io/controller-runtime/pkg/client\"\\n)\\ntype JindoEngine struct {\\n\\truntime     *datav1alpha1.JindoRuntime\\n\\tname        string\\n\\tnamespace   string\\n\\truntimeType string\\n\\tLog         logr.Logger\\n\\tclient.Client\\n\\t//When reaching this gracefulShutdownLimits, the system is forced to clean up.\\n\\tgracefulShutdownLimits int32\\n\\tretryShutdown          int32\\n\\tinitImage              string\\n}\\n\\nfunc Build(id string, ctx cruntime.ReconcileRequestContext) (base.Engine, error) {\\n\\tengine := &JindoEngine{\\n\\t\\tname:                   ctx.Name,\\n\\t\\tnamespace:              ctx.Namespace,\\n\\t\\tClient:                 ctx.Client,\\n\\t\\tLog:                    ctx.Log,\\n\\t\\truntimeType:            ctx.RuntimeType,\\n\\t\\tgracefulShutdownLimits: 5,\\n\\t\\tretryShutdown:          0,\\n\\t}\\n\\t// var implement base.Implement = engine\\n\\t// engine.TemplateEngine = template\\n\\tif ctx.Runtime != nil {\\n\\t\\truntime, ok := ctx.Runtime.(*datav1alpha1.JindoRuntime)\\n\\t\\tif !ok {\\n\\t\\t\\treturn nil, fmt.Errorf(\"engine %s is failed to parse\", ctx.Name)\\n\\t\\t}\\n\\t\\tengine.runtime = runtime\\n\\t} else {\\n\\t\\treturn nil, fmt.Errorf(\"engine %s is failed to parse\", ctx.Name)\\n\\t}\\n\\n\\ttemplate := base.NewTemplateEngine(engine, id, ctx)\\n\\n\\terr := kubeclient.EnsureNamespace(ctx.Client, ctx.Namespace)\\n\\treturn template, err\\n}\\n')])])]),n(\"p\",[e._v(\"在\"),n(\"code\",[e._v(\"pkg/ddc/factory.go\")]),e._v(\"中修改init函数：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language-golang extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v('func init() {\\n\\tbuildFuncMap = map[string]buildFunc{\\n\\t\\t\"alluxio\": alluxio.Build,\\n\\t\\t\"jindo\":   jindo.Build,\\n\\t}\\n}\\n')])])]),n(\"h2\",{attrs:{id:\"实现engine的生命周期\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#实现engine的生命周期\"}},[e._v(\"#\")]),e._v(\" 实现engine的生命周期\")]),e._v(\" \"),n(\"p\",[e._v(\"为JindoEngine实现刚刚介绍的那些方法，即可实现Jindo engine的生命周期。\")]),e._v(\" \"),n(\"p\",[e._v(\"创建PV时，如果是FusePV，可以使用Fluid提供的csi-nodeplugin，只要在PV的spec中添加如下字段：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\" csi:\\n  driver: fuse.csi.fluid.io\\n  volumeAttributes:\\n   fluid_path: /runtime-mnt/jindofs\\n   mount_type: fuse.alluxio-fuse\\n\")])])]),n(\"blockquote\",[n(\"p\",[e._v(\"将fluid_path和mount_type替换为实际的挂载目录和挂载种类。\")])]),e._v(\" \"),n(\"h2\",{attrs:{id:\"修改makefile\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#修改makefile\"}},[e._v(\"#\")]),e._v(\" 修改Makefile\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"JINDORUNTIME_CONTROLLER_IMG ?= xxx/xxx\\n\\njindoruntime-controller-build: generate fmt vet\\n\\tCGO_ENABLED=0 GOOS=linux GOARCH=amd64 GO111MODULE=off  go build -gcflags=\\\"-N -l\\\" -a -o bin/jindoruntime-controller -ldflags '${LDFLAGS}' cmd/jindo/main.go\\ndocker-build-jindoruntime-controller: generate fmt vet\\n\\tdocker build --no-cache . -f Dockerfile.jindoruntime -t ${JINDORUNTIME_CONTROLLER_IMG}:${GIT_VERSION}\\n\\n\")])])]),n(\"p\",[e._v(\"执行make命令时，会在api/v1alpha1/zz_generated.deepcopy.go中自动生成CRD的deepcopy等方法。\")])])}),[],!1,null,null,null);t.default=a.exports}}]);","extractedComments":[]}